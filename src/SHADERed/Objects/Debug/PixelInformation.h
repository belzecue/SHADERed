#pragma once
#include <SHADERed/Engine/Model.h>
#include <SHADERed/Objects/PipelineItem.h>

#include <glm/glm.hpp>
#include <unordered_map>

extern "C" {
	#include <spvm/result.h>
}

namespace ed {
	class PixelInformation {
	public:
		PixelInformation()
		{
			Color = DebuggerColor = glm::vec4(0.0f);
			Pass = nullptr;
			Object = nullptr;
			Fetched = false;
			Discarded = false;
			VertexCount = 0;
			RenderTexture = "";
			RenderTextureIndex = 0;
			InstanceID = 0;
			VertexID = 0;
		}
		glm::vec4 Color;		 // actual pixel color
		glm::vec4 DebuggerColor; // Color generated by the debugger - this way users can see if the SPIRV-VM is executing code correctly...

		PipelineItem* Pass;		   // shader pass responsible for this pixel
		PipelineItem* Object;	   // pipeline item responsible for this pixel


		std::string RenderTexture; // what render texture
		glm::ivec2 RenderTextureSize; // cache RT size
		int RenderTextureIndex;

		int InTopology, OutTopology; // In == vertex shader input, Out == geometry shader output

		int VertexID;				// gl_VertexID
		int InstanceID;				// gl_InstanceID

		glm::ivec2 Coordinate; // pixel position on the texture
		glm::vec2 RelativeCoordinate;

		bool Fetched;	// Did we fill the DebuggerColor and Vertex[] information for this pixel?
		bool Discarded; // was this pixel discarded?

		int VertexCount;					// 1 for point, 2 for line, 3 for triangle, etc...
		eng::Model::Mesh::Vertex Vertex[3]; // vertices that are responsible for this pixel
		glm::vec4 glPosition[3];			// position output from vertex shader
		std::vector<struct spvm_result> VertexShaderOutput[3];

		void* InstanceBuffer;
	};
}